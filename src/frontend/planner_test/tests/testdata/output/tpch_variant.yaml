# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    CREATE SOURCE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR,
            s_address VARCHAR,
            s_nationkey INTEGER,
            s_phone VARCHAR,
            s_acctbal NUMERIC,
            s_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE part (
            p_partkey INTEGER,
            p_name VARCHAR,
            p_mfgr VARCHAR,
            p_brand VARCHAR,
            p_type VARCHAR,
            p_size INTEGER,
            p_container VARCHAR,
            p_retailprice NUMERIC,
            p_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE customer (
            c_custkey INTEGER,
            c_name VARCHAR,
            c_address VARCHAR,
            c_nationkey INTEGER,
            c_phone VARCHAR,
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR,
            c_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR,
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR,
            o_clerk VARCHAR,
            o_shippriority INTEGER,
            o_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR,
            l_linestatus VARCHAR,
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR,
            l_shipmode VARCHAR,
            l_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE nation (
            n_nationkey INTEGER,
            n_name VARCHAR,
            n_regionkey INTEGER,
            n_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;

    CREATE SOURCE region (
            r_regionkey INTEGER,
            r_name VARCHAR,
            r_comment VARCHAR
    ) WITH( connector = 'datagen' ) FORMAT PLAIN ENCODE JSON;
- id: tpch_q2
  before:
  - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        part,
        supplier,
        partsupp,
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey;
  logical_plan: |-
    LogicalProject { exprs: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    └─LogicalFilter { predicate: (p_partkey = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (ps_supplycost = min(ps_supplycost)) }
      └─LogicalApply { type: LeftOuter, on: true, correlated_id: 1, max_one_row: true }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
        │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
        └─LogicalProject { exprs: [min(ps_supplycost)] }
          └─LogicalAgg { aggs: [min(ps_supplycost)] }
            └─LogicalProject { exprs: [ps_supplycost] }
              └─LogicalFilter { predicate: (CorrelatedInputRef { index: 0, correlated_id: 1 } = ps_partkey) AND (s_suppkey = ps_suppkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
                └─LogicalJoin { type: Inner, on: true, output: all }
                  ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ ├─LogicalJoin { type: Inner, on: true, output: all }
                  │ │ ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
                  │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
                  │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
                  └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
    ├─LogicalJoin { type: Inner, on: IsNotDistinctFrom(p_partkey, p_partkey) AND (ps_supplycost = min(ps_supplycost)), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
    │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
    │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
    │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │ │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │ └─LogicalAgg { group_key: [p_partkey], aggs: [min(ps_supplycost)] }
    │   └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(p_partkey, ps_partkey), output: [p_partkey, ps_supplycost] }
    │     ├─LogicalAgg { group_key: [p_partkey], aggs: [] }
    │     │ └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [p_partkey] }
    │     │   ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [p_partkey, n_regionkey] }
    │     │   │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [p_partkey, s_nationkey] }
    │     │   │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = ps_partkey), output: [p_partkey, ps_suppkey] }
    │     │   │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │     │   │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │     │   │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │     │   │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │     │   └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │     └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [ps_partkey, ps_supplycost] }
    │       ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [ps_partkey, ps_supplycost, n_regionkey] }
    │       │ ├─LogicalJoin { type: Inner, on: (s_suppkey = ps_suppkey), output: [ps_partkey, ps_supplycost, s_nationkey] }
    │       │ │ ├─LogicalFilter { predicate: IsNotNull(ps_partkey) }
    │       │ │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │       │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │       │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │       └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
    └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC], dist: Single }
    └─BatchSort { order: [s_acctbal DESC, n_name ASC, s_name ASC, p_partkey ASC] }
      └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment] }
        ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │ └─BatchHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
        │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_phone, s_acctbal, s_comment, n_name, n_regionkey] }
        │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
        │   │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost] }
        │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
        │   │   │   │   └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │   │   │   │     └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
        │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
        │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
        │   └─BatchHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost)] }
        │     └─BatchHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost] }
        │       ├─BatchHashAgg { group_key: [p_partkey], aggs: [] }
        │       │ └─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │       │   └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [p_partkey] }
        │       │     ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │       │     │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [p_partkey, n_regionkey] }
        │       │     │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │       │     │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, s_nationkey] }
        │       │     │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │       │     │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_suppkey] }
        │       │     │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
        │       │     │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
        │       │     │   │   │   └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │       │     │   │   │     └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
        │       │     │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │       │     │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
        │       │     │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │       │     │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
        │       │     └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
        │       │       └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
        │       └─BatchExchange { order: [], dist: HashShard(ps_partkey) }
        │         └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [ps_partkey, ps_supplycost] }
        │           ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
        │           │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, n_regionkey] }
        │           │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │           │   │ └─BatchHashJoin { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey] }
        │           │   │   ├─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
        │           │   │   │ └─BatchFilter { predicate: IsNotNull(ps_partkey) }
        │           │   │   │   └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
        │           │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │           │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
        │           │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │           │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
        │           └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
        │             └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
        └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
          └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), _row_id#1(hidden), r_regionkey(hidden), _row_id#2(hidden), _row_id#3(hidden), _row_id#4(hidden), ps_suppkey(hidden), n_nationkey(hidden), ps_supplycost(hidden), p_partkey#1(hidden)], stream_key: [_row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, p_partkey, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_conflict: NoCheck }
    └─StreamHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id, r_regionkey, _row_id, _row_id, _row_id, ps_suppkey, n_nationkey, ps_supplycost, p_partkey] }
      ├─StreamExchange { dist: HashShard(p_partkey) }
      │ └─StreamShare { id: 26 }
      │   └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] }
      │     ├─StreamExchange { dist: HashShard(n_nationkey) }
      │     │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
      │     │   ├─StreamExchange { dist: HashShard(r_regionkey) }
      │     │   │ └─StreamShare { id: 3 }
      │     │   │   └─StreamProject { exprs: [r_regionkey, _row_id] }
      │     │   │     └─StreamRowIdGen { row_id_index: 3 }
      │     │   │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
      │     │   └─StreamExchange { dist: HashShard(n_regionkey) }
      │     │     └─StreamShare { id: 7 }
      │     │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
      │     │         └─StreamRowIdGen { row_id_index: 4 }
      │     │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
      │     └─StreamExchange { dist: HashShard(s_nationkey) }
      │       └─StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] }
      │         ├─StreamExchange { dist: HashShard(ps_suppkey) }
      │         │ └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] }
      │         │   ├─StreamExchange { dist: HashShard(p_partkey) }
      │         │   │ └─StreamRowIdGen { row_id_index: 9 }
      │         │   │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
      │         │   └─StreamExchange { dist: HashShard(ps_partkey) }
      │         │     └─StreamShare { id: 15 }
      │         │       └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
      │         │         └─StreamRowIdGen { row_id_index: 5 }
      │         │           └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
      │         └─StreamExchange { dist: HashShard(s_suppkey) }
      │           └─StreamShare { id: 21 }
      │             └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
      │               └─StreamRowIdGen { row_id_index: 7 }
      │                 └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
      └─StreamProject { exprs: [p_partkey, min(ps_supplycost)] }
        └─StreamHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost), count] }
          └─StreamHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, _row_id, _row_id, r_regionkey, s_nationkey] }
            ├─StreamAppendOnlyDedup { dedup_cols: [p_partkey] }
            │ └─StreamExchange { dist: HashShard(p_partkey) }
            │   └─StreamProject { exprs: [p_partkey] }
            │     └─StreamShare { id: 26 }
            │       └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] }
            │         ├─StreamExchange { dist: HashShard(n_nationkey) }
            │         │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
            │         │   ├─StreamExchange { dist: HashShard(r_regionkey) }
            │         │   │ └─StreamShare { id: 3 }
            │         │   │   └─StreamProject { exprs: [r_regionkey, _row_id] }
            │         │   │     └─StreamRowIdGen { row_id_index: 3 }
            │         │   │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
            │         │   └─StreamExchange { dist: HashShard(n_regionkey) }
            │         │     └─StreamShare { id: 7 }
            │         │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
            │         │         └─StreamRowIdGen { row_id_index: 4 }
            │         │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
            │         └─StreamExchange { dist: HashShard(s_nationkey) }
            │           └─StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] }
            │             ├─StreamExchange { dist: HashShard(ps_suppkey) }
            │             │ └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] }
            │             │   ├─StreamExchange { dist: HashShard(p_partkey) }
            │             │   │ └─StreamRowIdGen { row_id_index: 9 }
            │             │   │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
            │             │   └─StreamExchange { dist: HashShard(ps_partkey) }
            │             │     └─StreamShare { id: 15 }
            │             │       └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
            │             │         └─StreamRowIdGen { row_id_index: 5 }
            │             │           └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
            │             └─StreamExchange { dist: HashShard(s_suppkey) }
            │               └─StreamShare { id: 21 }
            │                 └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            │                   └─StreamRowIdGen { row_id_index: 7 }
            │                     └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
            └─StreamExchange { dist: HashShard(ps_partkey) }
              └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] }
                ├─StreamExchange { dist: HashShard(s_nationkey) }
                │ └─StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] }
                │   ├─StreamExchange { dist: HashShard(ps_suppkey) }
                │   │ └─StreamFilter { predicate: IsNotNull(ps_partkey) }
                │   │   └─StreamShare { id: 15 }
                │   │     └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
                │   │       └─StreamRowIdGen { row_id_index: 5 }
                │   │         └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                │   └─StreamExchange { dist: HashShard(s_suppkey) }
                │     └─StreamShare { id: 21 }
                │       └─StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                │         └─StreamRowIdGen { row_id_index: 7 }
                │           └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                └─StreamExchange { dist: HashShard(n_nationkey) }
                  └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                    ├─StreamExchange { dist: HashShard(r_regionkey) }
                    │ └─StreamShare { id: 3 }
                    │   └─StreamProject { exprs: [r_regionkey, _row_id] }
                    │     └─StreamRowIdGen { row_id_index: 3 }
                    │       └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(n_regionkey) }
                      └─StreamShare { id: 7 }
                        └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                          └─StreamRowIdGen { row_id_index: 4 }
                            └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), _row_id#1(hidden), r_regionkey(hidden), _row_id#2(hidden), _row_id#3(hidden), _row_id#4(hidden), ps_suppkey(hidden), n_nationkey(hidden), ps_supplycost(hidden), p_partkey#1(hidden)], stream_key: [_row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, p_partkey, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_columns: [s_acctbal, n_name, s_name, p_partkey, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, p_partkey#1, ps_supplycost], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamHashJoin { type: Inner, predicate: p_partkey IS NOT DISTINCT FROM p_partkey AND ps_supplycost = min(ps_supplycost), output: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id, r_regionkey, _row_id, _row_id, _row_id, ps_suppkey, n_nationkey, ps_supplycost, p_partkey] } { left table: 0, right table: 2, left degree table: 1, right degree table: 3 }
        ├── StreamExchange Hash([0]) from 1
        └── StreamProject { exprs: [p_partkey, min(ps_supplycost)] }
            └── StreamHashAgg { group_key: [p_partkey], aggs: [min(ps_supplycost), count] } { result table: 26, state tables: [ 25 ], distinct tables: [] }
                └── StreamHashJoin { type: LeftOuter, predicate: p_partkey IS NOT DISTINCT FROM ps_partkey, output: [p_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, _row_id, _row_id, r_regionkey, s_nationkey] } { left table: 27, right table: 29, left degree table: 28, right degree table: 30 }
                    ├── StreamAppendOnlyDedup { dedup_cols: [p_partkey] } { state table: 31 }
                    │   └── StreamExchange Hash([0]) from 15
                    └── StreamExchange Hash([0]) from 16

    Fragment 1
    StreamNoOp
    └── StreamExchange NoShuffle from 2

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, _row_id, ps_suppkey] } { left table: 4, right table: 6, left degree table: 5, right degree table: 7 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([5]) from 8

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { left table: 8, right table: 10, left degree table: 9, right degree table: 11 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 6

    Fragment 4
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 5
    StreamProject { exprs: [r_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 3 }
        └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { source state table: 12 }

    Fragment 6
    StreamNoOp
    └── StreamExchange NoShuffle from 7

    Fragment 7
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 13 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id, ps_suppkey, _row_id] } { left table: 14, right table: 16, left degree table: 15, right degree table: 17 }
    ├── StreamExchange Hash([2]) from 9
    └── StreamExchange Hash([0]) from 13

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id] } { left table: 18, right table: 20, left degree table: 19, right degree table: 21 }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { source state table: 22 }

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 12

    Fragment 12
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_supplycost, _row_id] }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { source state table: 23 }

    Fragment 13
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 14
    StreamProject { exprs: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
    └── StreamRowIdGen { row_id_index: 7 }
        └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 24 }

    Fragment 15
    StreamProject { exprs: [p_partkey] }
    └── StreamExchange NoShuffle from 2

    Fragment 16
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [ps_partkey, ps_supplycost, _row_id, _row_id, ps_suppkey, s_nationkey, _row_id, _row_id, r_regionkey] } { left table: 32, right table: 34, left degree table: 33, right degree table: 35 }
    ├── StreamExchange Hash([2]) from 17
    └── StreamExchange Hash([0]) from 20

    Fragment 17
    StreamHashJoin [append_only] { type: Inner, predicate: ps_suppkey = s_suppkey, output: [ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id] } { left table: 36, right table: 38, left degree table: 37, right degree table: 39 }
    ├── StreamExchange Hash([1]) from 18
    └── StreamExchange Hash([0]) from 19

    Fragment 18
    StreamFilter { predicate: IsNotNull(ps_partkey) }
    └── StreamExchange NoShuffle from 12

    Fragment 19
    StreamNoOp
    └── StreamExchange NoShuffle from 14

    Fragment 20
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { left table: 40, right table: 42, left degree table: 41, right degree table: 43 }
    ├── StreamExchange Hash([0]) from 21
    └── StreamExchange Hash([2]) from 22

    Fragment 21
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 22
    StreamNoOp
    └── StreamExchange NoShuffle from 7

    Table 0 { columns: [ p_partkey, p_mfgr, s_name, s_address, s_phone, s_acctbal, s_comment, ps_supplycost, n_name, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1, _row_id_2, _row_id_3, ps_suppkey ], primary key: [ $0 ASC, $7 ASC, $9 ASC, $10 ASC, $11 ASC, $13 ASC, $14 ASC, $15 ASC, $16 ASC, $12 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ p_partkey, ps_supplycost, _row_id, _row_id_0, r_regionkey, _row_id_1, _row_id_2, _row_id_3, ps_suppkey, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ p_partkey, min(ps_supplycost) ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 3 { columns: [ p_partkey, min(ps_supplycost), _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 4 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ p_partkey, p_mfgr, ps_supplycost, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id, _row_id_0, ps_suppkey, _row_id_1 ], primary key: [ $5 ASC, $9 ASC, $10 ASC, $0 ASC, $12 ASC, $11 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], distribution key: [ 5 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ s_nationkey, _row_id, _row_id_0, p_partkey, _row_id_1, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ r_regionkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ p_partkey, p_mfgr, ps_suppkey, ps_supplycost, _row_id, _row_id_0 ], primary key: [ $2 ASC, $4 ASC, $5 ASC, $0 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_suppkey, _row_id, _row_id_0, p_partkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 23 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ p_partkey, ps_supplycost, _row_id, _row_id_0, ps_suppkey, _row_id_1, _row_id_2, r_regionkey, s_nationkey ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ p_partkey, min(ps_supplycost), count ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ p_partkey ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ p_partkey, _degree ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 29 { columns: [ ps_partkey, ps_supplycost, _row_id, _row_id_0, ps_suppkey, s_nationkey, _row_id_1, _row_id_2, r_regionkey ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $7 ASC, $8 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ ps_partkey, _row_id, _row_id_0, ps_suppkey, _row_id_1, _row_id_2, r_regionkey, s_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31 { columns: [ p_partkey ], primary key: [ $0 ASC ], value indices: [ 0 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 32 { columns: [ ps_partkey, ps_supplycost, s_nationkey, _row_id, ps_suppkey, _row_id_0 ], primary key: [ $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ s_nationkey, _row_id, _row_id_0, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 34 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 35 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 36 { columns: [ ps_partkey, ps_suppkey, ps_supplycost, _row_id ], primary key: [ $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 37 { columns: [ ps_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 38 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 39 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 40 { columns: [ r_regionkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 41 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 42 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 43 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id, _row_id#1, r_regionkey, _row_id#2, _row_id#3, _row_id#4, ps_suppkey, n_nationkey, ps_supplycost, p_partkey#1 ], primary key: [ $0 DESC, $2 ASC, $1 ASC, $3 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC, $14 ASC, $15 ASC, $17 ASC, $16 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ], distribution key: [ 3 ], read pk prefix len hint: 11 }

- id: tpch_q5
  before:
  - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
    group by
      n_name
    order by
      revenue desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, sum($expr1)] }
    └─LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
      └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
        └─LogicalFilter { predicate: (c_custkey = o_custkey) AND (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey) AND (c_nationkey = s_nationkey) AND (s_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) }
          └─LogicalJoin { type: Inner, on: true, output: all }
            ├─LogicalJoin { type: Inner, on: true, output: all }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
            └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name], aggs: [sum($expr1)] }
    └─LogicalProject { exprs: [n_name, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr1] }
      └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, n_name] }
        ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, n_regionkey] }
        │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey) AND (l_suppkey = s_suppkey), output: [s_nationkey, l_extendedprice, l_discount] }
        │ │ ├─LogicalJoin { type: Inner, on: (c_nationkey = s_nationkey), output: [o_orderkey, s_suppkey, s_nationkey] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [c_nationkey, o_orderkey] }
        │ │ │ │ ├─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
        └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [sum($expr1) DESC], dist: Single }
    └─BatchSort { order: [sum($expr1) DESC] }
      └─BatchHashAgg { group_key: [n_name], aggs: [sum($expr1)] }
        └─BatchExchange { order: [], dist: HashShard(n_name) }
          └─BatchProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1] }
            └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
              │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, n_regionkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: o_orderkey = l_orderkey AND s_suppkey = l_suppkey, output: [s_nationkey, l_extendedprice, l_discount] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(o_orderkey, s_suppkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = s_nationkey, output: [o_orderkey, s_suppkey, s_nationkey] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: c_custkey = o_custkey, output: [c_nationkey, o_orderkey] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │   │   │   │   │ └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
              │   │   └─BatchExchange { order: [], dist: HashShard(l_orderkey, l_suppkey) }
              │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
              │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
              └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, sum($expr1)] }
      └─StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
        └─StreamExchange { dist: HashShard(n_name) }
          └─StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey, n_nationkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
              ├─StreamExchange { dist: HashShard(n_nationkey, n_nationkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] }
              │   ├─StreamExchange { dist: HashShard(r_regionkey) }
              │   │ └─StreamRowIdGen { row_id_index: 3 }
              │   │   └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(n_regionkey) }
              │     └─StreamFilter { predicate: (n_nationkey = n_nationkey) }
              │       └─StreamRowIdGen { row_id_index: 4 }
              │         └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              └─StreamExchange { dist: HashShard(c_nationkey, s_nationkey) }
                └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
                  ├─StreamExchange { dist: HashShard(o_orderkey, c_nationkey) }
                  │ └─StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] }
                  │   ├─StreamExchange { dist: HashShard(o_custkey) }
                  │   │ └─StreamRowIdGen { row_id_index: 9 }
                  │   │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                  │   └─StreamExchange { dist: HashShard(c_custkey) }
                  │     └─StreamRowIdGen { row_id_index: 8 }
                  │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  └─StreamExchange { dist: HashShard(l_orderkey, s_nationkey) }
                    └─StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] }
                      ├─StreamExchange { dist: HashShard(l_suppkey) }
                      │ └─StreamRowIdGen { row_id_index: 16 }
                      │   └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                      └─StreamExchange { dist: HashShard(s_suppkey) }
                        └─StreamRowIdGen { row_id_index: 7 }
                          └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [n_name, revenue], stream_key: [n_name], pk_columns: [revenue, n_name], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, sum($expr1)] }
        └── StreamHashAgg [append_only] { group_key: [n_name], aggs: [sum($expr1), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, (l_extendedprice * (1:Decimal - l_discount)) as $expr1, _row_id, _row_id, r_regionkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey, n_nationkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey AND n_nationkey = c_nationkey, output: [l_extendedprice, l_discount, n_name, _row_id, _row_id, r_regionkey, n_nationkey, _row_id, _row_id, o_custkey, _row_id, _row_id, l_suppkey, o_orderkey, c_nationkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([0, 0]) from 2
        └── StreamExchange Hash([0, 3]) from 5

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, n_name, _row_id, r_regionkey, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([2]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { source state table: 9 }

    Fragment 4
    StreamFilter { predicate: (n_nationkey = n_nationkey) }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 10 }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey AND c_nationkey = s_nationkey, output: [c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id, o_custkey, o_orderkey, _row_id, _row_id, l_suppkey] }
    ├── left table: 11
    ├── right table: 13
    ├── left degree table: 12
    ├── right degree table: 14
    ├── StreamExchange Hash([0, 1]) from 6
    └── StreamExchange Hash([0, 3]) from 9

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_custkey = c_custkey, output: [o_orderkey, c_nationkey, _row_id, o_custkey, _row_id] } { left table: 15, right table: 17, left degree table: 16, right degree table: 18 }
    ├── StreamExchange Hash([1]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { source state table: 19 }

    Fragment 8
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { source state table: 20 }

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id] } { left table: 21, right table: 23, left degree table: 22, right degree table: 24 }
    ├── StreamExchange Hash([2]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 10
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { source state table: 25 }

    Fragment 11
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 26 }

    Table 0 { columns: [ n_name, sum($expr1), count ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ n_nationkey, n_name, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 0 ], read pk prefix len hint: 2 }

    Table 2 { columns: [ n_nationkey, n_nationkey_0, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 1, 0 ], read pk prefix len hint: 2 }

    Table 3
    ├── columns: [ c_nationkey, l_extendedprice, l_discount, s_nationkey, _row_id, _row_id_0, o_custkey, o_orderkey, _row_id_1, _row_id_2, l_suppkey ]
    ├── primary key: [ $3 ASC, $0 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 0, 3 ]
    └── read pk prefix len hint: 2

    Table 4
    ├── columns: [ s_nationkey, c_nationkey, _row_id, _row_id_0, o_custkey, _row_id_1, _row_id_2, l_suppkey, o_orderkey, _degree ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC ]
    ├── value indices: [ 9 ]
    ├── distribution key: [ 1, 0 ]
    └── read pk prefix len hint: 2

    Table 5 { columns: [ r_regionkey, r_name, r_comment, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $2 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ o_orderkey, c_nationkey, _row_id, o_custkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ o_orderkey, c_nationkey, _row_id, _row_id_0, o_custkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ l_orderkey, l_extendedprice, l_discount, s_nationkey, _row_id, l_suppkey, _row_id_0 ], primary key: [ $0 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 0, 3 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ l_orderkey, s_nationkey, _row_id, _row_id_0, l_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 15 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $1 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ o_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $0 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ c_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 22 { columns: [ l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $0 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ s_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ n_name, revenue ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q7
  before:
  - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  logical_plan: |-
    LogicalProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
    └─LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (c_custkey = o_custkey) AND (s_nationkey = n_nationkey) AND (c_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
              └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
    └─LogicalProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2] }
      └─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
        ├─LogicalJoin { type: Inner, on: (c_custkey = o_custkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
        │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
        │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
        │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
        │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
        └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, n_name ASC, $expr1 ASC], dist: Single }
    └─BatchSort { order: [n_name ASC, n_name ASC, $expr1 ASC] }
      └─BatchHashAgg { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2)] }
        └─BatchExchange { order: [], dist: HashShard(n_name, n_name, $expr1) }
          └─BatchProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2] }
            └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name] }
              ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
              │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, c_nationkey] }
              │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
              │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, o_custkey] }
              │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, l_shipdate, n_name] }
              │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
              │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_nationkey, l_orderkey, l_extendedprice, l_discount, l_shipdate] }
              │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
              │   │   │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
              │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
              │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
              │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
              │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
              │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
              │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
              │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
              │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
              └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
      └─StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(n_name, n_name, $expr1) }
          └─StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
              ├─StreamExchange { dist: HashShard(l_orderkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
              │   ├─StreamExchange { dist: HashShard(s_suppkey) }
              │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
              │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
              │   │   │ └─StreamShare { id: 3 }
              │   │   │   └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
              │   │   │     └─StreamRowIdGen { row_id_index: 4 }
              │   │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
              │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
              │   │     └─StreamRowIdGen { row_id_index: 7 }
              │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(l_suppkey) }
              │     └─StreamRowIdGen { row_id_index: 16 }
              │       └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
              └─StreamExchange { dist: HashShard(o_orderkey) }
                └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] }
                  ├─StreamExchange { dist: HashShard(c_custkey) }
                  │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] }
                  │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                  │   │ └─StreamShare { id: 3 }
                  │   │   └─StreamProject { exprs: [n_nationkey, n_name, _row_id] }
                  │   │     └─StreamRowIdGen { row_id_index: 4 }
                  │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                  │   └─StreamExchange { dist: HashShard(c_nationkey) }
                  │     └─StreamRowIdGen { row_id_index: 8 }
                  │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                  └─StreamExchange { dist: HashShard(o_custkey) }
                    └─StreamRowIdGen { row_id_index: 9 }
                      └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, revenue], stream_key: [supp_nation, cust_nation, l_year], pk_columns: [supp_nation, cust_nation, l_year], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, n_name, $expr1, sum($expr2)] }
        └── StreamHashAgg [append_only] { group_key: [n_name, n_name, $expr1], aggs: [sum($expr2), count] } { result table: 0, state tables: [], distinct tables: [] }
            └── StreamExchange Hash([0, 1, 2]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, n_name, Extract('YEAR':Varchar, l_shipdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey, l_orderkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, l_shipdate, n_name, n_name, _row_id, _row_id, n_nationkey, _row_id, s_suppkey, l_orderkey, _row_id, _row_id, n_nationkey, _row_id, c_custkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([1]) from 2
        └── StreamExchange Hash([1]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id, n_nationkey, s_suppkey, _row_id] }
    ├── left table: 5
    ├── right table: 7
    ├── left degree table: 6
    ├── right degree table: 8
    ├── StreamExchange Hash([1]) from 3
    └── StreamExchange Hash([2]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 9, right table: 11, left degree table: 10, right degree table: 12 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 6

    Fragment 4
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 5
    StreamProject { exprs: [n_nationkey, n_name, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 13 }

    Fragment 6
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 14 }

    Fragment 7
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
        └── source state table: 15

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [n_name, o_orderkey, _row_id, _row_id, n_nationkey, c_custkey, _row_id] } { left table: 16, right table: 18, left degree table: 17, right degree table: 19 }
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([1]) from 12

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [n_name, c_custkey, _row_id, n_nationkey, _row_id] } { left table: 20, right table: 22, left degree table: 21, right degree table: 23 }
    ├── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([3]) from 11

    Fragment 10
    StreamNoOp
    └── StreamExchange NoShuffle from 5

    Fragment 11
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { source state table: 24 }

    Fragment 12
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { source state table: 25 }

    Table 0 { columns: [ n_name, n_name_0, $expr1, sum($expr2), count ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3, 4 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

    Table 1
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1 ]
    ├── primary key: [ $1 ASC, $5 ASC, $6 ASC, $7 ASC, $9 ASC, $8 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ n_name, o_orderkey, _row_id, _row_id_0, n_nationkey, c_custkey, _row_id_1 ], primary key: [ $1 ASC, $2 ASC, $3 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ o_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, c_custkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $2 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 1

    Table 8 { columns: [ l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ n_nationkey, n_name, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_name, c_custkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ c_custkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ]
    ├── primary key: [ $1 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 19 { columns: [ o_custkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_nationkey, n_name, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ c_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ supp_nation, cust_nation, l_year, revenue ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1, 2 ], read pk prefix len hint: 3 }

- id: tpch_q8
  before:
  - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation != 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          part,
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and s_nationkey = n2.n_nationkey
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  logical_plan: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalFilter { predicate: (p_partkey = l_partkey) AND (s_suppkey = l_suppkey) AND (l_orderkey = o_orderkey) AND (o_custkey = c_custkey) AND (c_nationkey = n_nationkey) AND (n_regionkey = r_regionkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
              └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
    └─LogicalAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
      └─LogicalProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Int32::Decimal) as $expr3, $expr2] }
        └─LogicalProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Int32::Decimal - l_discount)) as $expr2, n_name] }
          └─LogicalJoin { type: Inner, on: (n_regionkey = r_regionkey), output: [l_extendedprice, l_discount, o_orderdate, n_name] }
            ├─LogicalJoin { type: Inner, on: (c_nationkey = n_nationkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
            │ ├─LogicalJoin { type: Inner, on: (o_custkey = c_custkey), output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
            │ │ ├─LogicalJoin { type: Inner, on: (l_orderkey = o_orderkey), output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
            │ │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_extendedprice, l_discount, n_name] }
            │ │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
            │ │ │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
            │ │ │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ └─LogicalSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
            └─LogicalSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [$expr1 ASC], dist: Single }
    └─BatchProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─BatchSort { order: [$expr1 ASC] }
        └─BatchHashAgg { group_key: [$expr1], aggs: [sum($expr3), sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard($expr1) }
            └─BatchProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2] }
              └─BatchProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name] }
                └─BatchHashJoin { type: Inner, predicate: n_regionkey = r_regionkey, output: [l_extendedprice, l_discount, o_orderdate, n_name] }
                  ├─BatchExchange { order: [], dist: HashShard(n_regionkey) }
                  │ └─BatchHashJoin { type: Inner, predicate: c_nationkey = n_nationkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, n_regionkey] }
                  │   ├─BatchExchange { order: [], dist: HashShard(c_nationkey) }
                  │   │ └─BatchHashJoin { type: Inner, predicate: o_custkey = c_custkey, output: [l_extendedprice, l_discount, n_name, o_orderdate, c_nationkey] }
                  │   │   ├─BatchExchange { order: [], dist: HashShard(o_custkey) }
                  │   │   │ └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_extendedprice, l_discount, n_name, o_custkey, o_orderdate] }
                  │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                  │   │   │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_extendedprice, l_discount, n_name] }
                  │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                  │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_extendedprice, l_discount, s_nationkey] }
                  │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                  │   │   │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                  │   │   │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                  │   │   │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                  │   │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                  │   │   │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                  │   │   │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                  │   │   │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                  │   │   │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │   │   │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                  │   │   │   └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  │   │   │     └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
                  │   │   └─BatchExchange { order: [], dist: HashShard(c_custkey) }
                  │   │     └─BatchSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id], filter: (None, None) }
                  │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                  │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                  └─BatchExchange { order: [], dist: HashShard(r_regionkey) }
                    └─BatchSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
      └─StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
            └─StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
                ├─StreamExchange { dist: HashShard(c_custkey) }
                │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] }
                │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] }
                │   │   ├─StreamExchange { dist: HashShard(r_regionkey) }
                │   │   │ └─StreamRowIdGen { row_id_index: 3 }
                │   │   │   └─StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] }
                │   │   └─StreamExchange { dist: HashShard(n_regionkey) }
                │   │     └─StreamShare { id: 5 }
                │   │       └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                │   │         └─StreamRowIdGen { row_id_index: 4 }
                │   │           └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─StreamExchange { dist: HashShard(c_nationkey) }
                │     └─StreamRowIdGen { row_id_index: 8 }
                │       └─StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] }
                └─StreamExchange { dist: HashShard(o_custkey) }
                  └─StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
                    ├─StreamExchange { dist: HashShard(l_orderkey) }
                    │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] }
                    │   ├─StreamExchange { dist: HashShard(s_suppkey) }
                    │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                    │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                    │   │   │ └─StreamShare { id: 5 }
                    │   │   │   └─StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
                    │   │   │     └─StreamRowIdGen { row_id_index: 4 }
                    │   │   │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                    │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
                    │   │     └─StreamRowIdGen { row_id_index: 7 }
                    │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                    │   └─StreamExchange { dist: HashShard(l_suppkey) }
                    │     └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] }
                    │       ├─StreamExchange { dist: HashShard(p_partkey) }
                    │       │ └─StreamRowIdGen { row_id_index: 9 }
                    │       │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                    │       └─StreamExchange { dist: HashShard(l_partkey) }
                    │         └─StreamRowIdGen { row_id_index: 16 }
                    │           └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(o_orderkey) }
                      └─StreamRowIdGen { row_id_index: 9 }
                        └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [o_year, mkt_share], stream_key: [o_year], pk_columns: [o_year], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [$expr1, RoundDigit((sum($expr3) / sum($expr2)), 6:Int32) as $expr4] }
        └── StreamHashAgg [append_only] { group_key: [$expr1], aggs: [sum($expr3), sum($expr2), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [$expr1, Case((n_name <> 'IRAN':Varchar), $expr2, 0:Decimal) as $expr3, $expr2, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
    └── StreamProject { exprs: [Extract('YEAR':Varchar, o_orderdate) as $expr1, (l_extendedprice * (1:Decimal - l_discount)) as $expr2, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey, c_custkey] }
        └── StreamHashJoin [append_only] { type: Inner, predicate: c_custkey = o_custkey, output: [l_extendedprice, l_discount, o_orderdate, n_name, _row_id, _row_id, r_regionkey, _row_id, n_nationkey, c_custkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, _row_id, l_orderkey] }
            ├── left table: 1
            ├── right table: 3
            ├── left degree table: 2
            ├── right degree table: 4
            ├── StreamExchange Hash([0]) from 2
            └── StreamExchange Hash([3]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = c_nationkey, output: [c_custkey, _row_id, _row_id, r_regionkey, n_nationkey, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([3]) from 7

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: r_regionkey = n_regionkey, output: [n_nationkey, _row_id, r_regionkey, _row_id] } { left table: 9, right table: 11, left degree table: 10, right degree table: 12 }
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([2]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 3 }
    └── StreamSource { source: region, columns: [r_regionkey, r_name, r_comment, _row_id] } { source state table: 13 }

    Fragment 5
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 6
    StreamProject { exprs: [n_nationkey, n_name, n_regionkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 4 }
        └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 14 }

    Fragment 7
    StreamRowIdGen { row_id_index: 8 }
    └── StreamSource { source: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id] } { source state table: 15 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: l_orderkey = o_orderkey, output: [n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id, n_nationkey, _row_id, _row_id, p_partkey, s_suppkey, l_orderkey, _row_id] }
    ├── left table: 16
    ├── right table: 18
    ├── left degree table: 17
    ├── right degree table: 19
    ├── StreamExchange Hash([1]) from 9
    └── StreamExchange Hash([0]) from 16

    Fragment 9
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, p_partkey] } { left table: 20, right table: 22, left degree table: 21, right degree table: 23 }
    ├── StreamExchange Hash([1]) from 10
    └── StreamExchange Hash([1]) from 13

    Fragment 10
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 24, right table: 26, left degree table: 25, right degree table: 27 }
    ├── StreamExchange Hash([0]) from 11
    └── StreamExchange Hash([3]) from 12

    Fragment 11
    StreamNoOp
    └── StreamExchange NoShuffle from 6

    Fragment 12
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 28 }

    Fragment 13
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id] } { left table: 29, right table: 31, left degree table: 30, right degree table: 32 }
    ├── StreamExchange Hash([0]) from 14
    └── StreamExchange Hash([1]) from 15

    Fragment 14
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { source state table: 33 }

    Fragment 15
    StreamRowIdGen { row_id_index: 16 }
    └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { source state table: 34 }

    Fragment 16
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { source state table: 35 }

    Table 0 { columns: [ $expr1, sum($expr3), sum($expr2), count ], primary key: [ $0 ASC ], value indices: [ 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, n_nationkey, _row_id_1 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ c_custkey, _row_id, _row_id_0, r_regionkey, _row_id_1, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3
    ├── columns: [ n_name, l_extendedprice, l_discount, o_custkey, o_orderdate, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, l_orderkey, _row_id_3 ]
    ├── primary key: [ $3 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $13 ASC, $12 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 3 ]
    └── read pk prefix len hint: 1

    Table 4
    ├── columns: [ o_custkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _row_id_3, l_orderkey, _degree ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 10 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 5 { columns: [ n_nationkey, _row_id, r_regionkey, _row_id_0 ], primary key: [ $0 ASC, $1 ASC, $3 ASC, $2 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, _row_id, _row_id_0, r_regionkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_mktsegment, c_comment, _row_id ], primary key: [ $3 ASC, $8 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ c_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ r_regionkey, r_name, r_comment, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ r_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $2 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ n_regionkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 14 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 15 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 16
    ├── columns: [ n_name, l_orderkey, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, p_partkey ]
    ├── primary key: [ $1 ASC, $4 ASC, $5 ASC, $6 ASC, $8 ASC, $9 ASC, $10 ASC, $7 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 17 { columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, p_partkey, s_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ], value indices: [ 8 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 20 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id, p_partkey, _row_id_0 ], primary key: [ $1 ASC, $4 ASC, $6 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ l_suppkey, _row_id, _row_id_0, p_partkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 24 { columns: [ n_nationkey, n_name, n_regionkey, _row_id ], primary key: [ $0 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 26 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 27 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 28 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 29 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 30 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 31
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $1 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 32 { columns: [ l_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 33 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 34 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 35 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ o_year, mkt_share ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- id: tpch_q9
  before:
  - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          part,
          supplier,
          lineitem,
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  logical_plan: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, $expr1, $expr2] }
        └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
          └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey) AND (p_partkey = l_partkey) AND (o_orderkey = l_orderkey) AND (s_nationkey = n_nationkey) }
            └─LogicalJoin { type: Inner, on: true, output: all }
              ├─LogicalJoin { type: Inner, on: true, output: all }
              │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
              │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
              └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
    └─LogicalAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
      └─LogicalProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Int32::Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
        └─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
          ├─LogicalJoin { type: Inner, on: (ps_suppkey = l_suppkey) AND (ps_partkey = l_partkey), output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
          │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
          │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
          │ │ │ ├─LogicalJoin { type: Inner, on: (p_partkey = l_partkey), output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
          │ │ │ │ ├─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │ │ │ └─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
          │ └─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
          └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [n_name ASC, $expr1 DESC], dist: Single }
    └─BatchProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─BatchSort { order: [n_name ASC, $expr1 DESC] }
        └─BatchHashAgg { group_key: [n_name, $expr1], aggs: [sum($expr2)] }
          └─BatchExchange { order: [], dist: HashShard(n_name, $expr1) }
            └─BatchProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2] }
              └─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name] }
                ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
                │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = ps_suppkey AND l_partkey = ps_partkey, output: [l_orderkey, l_quantity, l_extendedprice, l_discount, n_name, ps_supplycost] }
                │   ├─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                │   │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, n_name] }
                │   │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
                │   │   │ └─BatchHashJoin { type: Inner, predicate: l_suppkey = s_suppkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, s_nationkey] }
                │   │   │   ├─BatchExchange { order: [], dist: HashShard(l_suppkey) }
                │   │   │   │ └─BatchHashJoin { type: Inner, predicate: p_partkey = l_partkey, output: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                │   │   │   │   ├─BatchExchange { order: [], dist: HashShard(p_partkey) }
                │   │   │   │   │ └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                │   │   │   │   └─BatchExchange { order: [], dist: HashShard(l_partkey) }
                │   │   │   │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
                │   │   │   └─BatchExchange { order: [], dist: HashShard(s_suppkey) }
                │   │   │     └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
                │   │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
                │   │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
                │   └─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                │     └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
                └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
                  └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    └─StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
      └─StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
        └─StreamExchange { dist: HashShard(n_name, $expr1) }
          └─StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, ps_suppkey, ps_partkey] }
            └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
              ├─StreamExchange { dist: HashShard(ps_suppkey) }
              │ └─StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] }
              │   ├─StreamExchange { dist: HashShard(p_partkey) }
              │   │ └─StreamRowIdGen { row_id_index: 9 }
              │   │   └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              │   └─StreamExchange { dist: HashShard(ps_partkey) }
              │     └─StreamFilter { predicate: (ps_suppkey = ps_suppkey) }
              │       └─StreamRowIdGen { row_id_index: 5 }
              │         └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] }
                ├─StreamExchange { dist: HashShard(s_suppkey) }
                │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] }
                │   ├─StreamExchange { dist: HashShard(n_nationkey) }
                │   │ └─StreamRowIdGen { row_id_index: 4 }
                │   │   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
                │   └─StreamExchange { dist: HashShard(s_nationkey) }
                │     └─StreamRowIdGen { row_id_index: 7 }
                │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
                └─StreamExchange { dist: HashShard(l_suppkey) }
                  └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] }
                    ├─StreamExchange { dist: HashShard(o_orderkey) }
                    │ └─StreamRowIdGen { row_id_index: 9 }
                    │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(l_orderkey) }
                      └─StreamFilter { predicate: (l_partkey = l_partkey) }
                        └─StreamRowIdGen { row_id_index: 16 }
                          └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [nation, o_year, sum_profit], stream_key: [nation, o_year], pk_columns: [nation, o_year], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [n_name, $expr1, RoundDigit(sum($expr2), 2:Int32) as $expr3] }
        └── StreamHashAgg [append_only] { group_key: [n_name, $expr1], aggs: [sum($expr2), count] }
            ├── result table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0, 1]) from 1

    Fragment 1
    StreamProject { exprs: [n_name, Extract('YEAR':Varchar, o_orderdate) as $expr1, ((l_extendedprice * (1:Decimal - l_discount)) - (ps_supplycost * l_quantity)) as $expr2, _row_id, _row_id, p_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, ps_suppkey, ps_partkey] }
    └── StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = l_partkey AND ps_suppkey = l_suppkey AND ps_partkey = l_partkey AND ps_suppkey = s_suppkey, output: [l_quantity, l_extendedprice, l_discount, ps_supplycost, o_orderdate, n_name, _row_id, _row_id, p_partkey, ps_suppkey, ps_partkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
        ├── left table: 1
        ├── right table: 3
        ├── left degree table: 2
        ├── right degree table: 4
        ├── StreamExchange Hash([2]) from 2
        └── StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey] } { left table: 11, right table: 13, left degree table: 12, right degree table: 14 }
            ├── StreamExchange Hash([1]) from 5
            └── StreamExchange Hash([2]) from 8

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: p_partkey = ps_partkey, output: [p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id] } { left table: 5, right table: 7, left degree table: 6, right degree table: 8 }
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([0]) from 4

    Fragment 3
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { source state table: 9 }

    Fragment 4
    StreamFilter { predicate: (ps_suppkey = ps_suppkey) }
    └── StreamRowIdGen { row_id_index: 5 }
        └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { source state table: 10 }

    Fragment 5
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [n_name, s_suppkey, _row_id, n_nationkey, _row_id] } { left table: 15, right table: 17, left degree table: 16, right degree table: 18 }
    ├── StreamExchange Hash([0]) from 6
    └── StreamExchange Hash([3]) from 7

    Fragment 6
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 19 }

    Fragment 7
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 20 }

    Fragment 8
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id] } { left table: 21, right table: 23, left degree table: 22, right degree table: 24 }
    ├── StreamExchange Hash([0]) from 9
    └── StreamExchange Hash([0]) from 10

    Fragment 9
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { source state table: 25 }

    Fragment 10
    StreamFilter { predicate: (l_partkey = l_partkey) }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] } { source state table: 26 }

    Table 0 { columns: [ n_name, $expr1, sum($expr2), count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 1 { columns: [ p_partkey, ps_partkey, ps_suppkey, ps_supplycost, _row_id, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $1 ASC, $2 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 2 ], read pk prefix len hint: 4 }

    Table 2 { columns: [ p_partkey, ps_suppkey, ps_partkey, ps_suppkey_0, _row_id, _row_id_0, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 6 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 3
    ├── columns: [ n_name, s_suppkey, o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey ]
    ├── primary key: [ $3 ASC, $4 ASC, $3 ASC, $1 ASC, $8 ASC, $9 ASC, $10 ASC, $11 ASC, $12 ASC, $13 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 4

    Table 4 { columns: [ l_partkey, l_suppkey, l_partkey_0, s_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ], value indices: [ 10 ], distribution key: [ 3 ], read pk prefix len hint: 4 }

    Table 5 { columns: [ p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 11 { columns: [ n_name, s_suppkey, _row_id, n_nationkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ o_orderdate, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id, o_orderkey, _row_id_0 ], primary key: [ $2 ASC, $6 ASC, $8 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], distribution key: [ 2 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 21 { columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ], primary key: [ $0 ASC, $9 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23
    ├── columns: [ l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id ]
    ├── primary key: [ $0 ASC, $16 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 24 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 25 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ nation, o_year, sum_profit ], primary key: [ $0 ASC, $1 DESC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

- id: tpch_q20
  before:
  - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
          )
      )
      and s_nationkey = n_nationkey
    order by
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, s_address] }
    └─LogicalFilter { predicate: (s_nationkey = n_nationkey) }
      └─LogicalApply { type: LeftSemi, on: (s_suppkey = ps_suppkey), correlated_id: 1 }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
        │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
        └─LogicalProject { exprs: [ps_suppkey] }
          └─LogicalFilter { predicate: (ps_availqty::Decimal > $expr1) }
            └─LogicalApply { type: LeftOuter, on: true, correlated_id: 3, max_one_row: true }
              ├─LogicalApply { type: LeftSemi, on: (ps_partkey = p_partkey), correlated_id: 2 }
              │ ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
              │ └─LogicalProject { exprs: [p_partkey] }
              │   └─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
              └─LogicalProject { exprs: [(0.5:Decimal * sum(l_quantity)) as $expr1] }
                └─LogicalAgg { aggs: [sum(l_quantity)] }
                  └─LogicalProject { exprs: [l_quantity] }
                    └─LogicalFilter { predicate: (l_partkey = CorrelatedInputRef { index: 0, correlated_id: 3 }) AND (l_suppkey = CorrelatedInputRef { index: 1, correlated_id: 3 }) }
                      └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalJoin { type: LeftSemi, on: (s_suppkey = ps_suppkey), output: [s_name, s_address] }
    ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_suppkey, s_name, s_address] }
    │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
    │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
    └─LogicalJoin { type: Inner, on: IsNotDistinctFrom(ps_partkey, ps_partkey) AND IsNotDistinctFrom(ps_suppkey, ps_suppkey) AND ($expr1 > $expr2), output: [ps_suppkey] }
      ├─LogicalProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
      │ └─LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey, ps_availqty] }
      │   ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
      │   └─LogicalProject { exprs: [p_partkey] }
      │     └─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
      └─LogicalProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
        └─LogicalAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity)] }
          └─LogicalJoin { type: LeftOuter, on: IsNotDistinctFrom(ps_partkey, l_partkey) AND IsNotDistinctFrom(ps_suppkey, l_suppkey), output: [ps_partkey, ps_suppkey, l_quantity] }
            ├─LogicalAgg { group_key: [ps_partkey, ps_suppkey], aggs: [] }
            │ └─LogicalJoin { type: LeftSemi, on: (ps_partkey = p_partkey), output: [ps_partkey, ps_suppkey] }
            │   ├─LogicalSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │   └─LogicalProject { exprs: [p_partkey] }
            │     └─LogicalSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], time_range: (Unbounded, Unbounded) }
            └─LogicalProject { exprs: [l_partkey, l_suppkey, l_quantity] }
              └─LogicalFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [s_name ASC], dist: Single }
    └─BatchSort { order: [s_name ASC] }
      └─BatchHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address] }
        ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
        │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address] }
        │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
        │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
        │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
        │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
        └─BatchExchange { order: [], dist: HashShard(ps_suppkey) }
          └─BatchHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey AND ($expr1 > $expr2), output: [ps_suppkey] }
            ├─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
            │ └─BatchProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1] }
            │   └─BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty] }
            │     ├─BatchExchange { order: [], dist: HashShard(ps_partkey) }
            │     │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
            │     └─BatchExchange { order: [], dist: HashShard(p_partkey) }
            │       └─BatchProject { exprs: [p_partkey] }
            │         └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
            └─BatchProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
              └─BatchHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity)] }
                └─BatchHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity] }
                  ├─BatchExchange { order: [], dist: HashShard(ps_partkey, ps_suppkey) }
                  │ └─BatchHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [] }
                  │   └─BatchHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey] }
                  │     ├─BatchExchange { order: [], dist: HashShard(ps_partkey) }
                  │     │ └─BatchSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id], filter: (None, None) }
                  │     └─BatchExchange { order: [], dist: HashShard(p_partkey) }
                  │       └─BatchProject { exprs: [p_partkey] }
                  │         └─BatchSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id], filter: (None, None) }
                  └─BatchExchange { order: [], dist: HashShard(l_partkey, l_suppkey) }
                    └─BatchProject { exprs: [l_partkey, l_suppkey, l_quantity] }
                      └─BatchFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                        └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: NoCheck }
    └─StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] }
      ├─StreamExchange { dist: HashShard(s_suppkey) }
      │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] }
      │   ├─StreamExchange { dist: HashShard(s_nationkey) }
      │   │ └─StreamRowIdGen { row_id_index: 7 }
      │   │   └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
      │   └─StreamExchange { dist: HashShard(n_nationkey) }
      │     └─StreamRowIdGen { row_id_index: 4 }
      │       └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
      └─StreamExchange { dist: HashShard(ps_suppkey) }
        └─StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, ps_partkey, ps_suppkey] }
          └─StreamFilter { predicate: ($expr1 > $expr2) }
            └─StreamHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey, output: all }
              ├─StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
              │ └─StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
              │   └─StreamShare { id: 13 }
              │     └─StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
              │       ├─StreamExchange { dist: HashShard(ps_partkey) }
              │       │ └─StreamRowIdGen { row_id_index: 5 }
              │       │   └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
              │       └─StreamExchange { dist: HashShard(p_partkey) }
              │         └─StreamProject { exprs: [p_partkey, _row_id] }
              │           └─StreamRowIdGen { row_id_index: 9 }
              │             └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
              └─StreamProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
                └─StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity), count] }
                  └─StreamHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity, _row_id] }
                    ├─StreamExchange { dist: HashShard(ps_partkey, ps_suppkey) }
                    │ └─StreamProject { exprs: [ps_partkey, ps_suppkey] }
                    │   └─StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [count] }
                    │     └─StreamShare { id: 13 }
                    │       └─StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] }
                    │         ├─StreamExchange { dist: HashShard(ps_partkey) }
                    │         │ └─StreamRowIdGen { row_id_index: 5 }
                    │         │   └─StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] }
                    │         └─StreamExchange { dist: HashShard(p_partkey) }
                    │           └─StreamProject { exprs: [p_partkey, _row_id] }
                    │             └─StreamRowIdGen { row_id_index: 9 }
                    │               └─StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] }
                    └─StreamExchange { dist: HashShard(l_partkey, l_suppkey) }
                      └─StreamProject { exprs: [l_partkey, l_suppkey, l_quantity, _row_id] }
                        └─StreamFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
                          └─StreamRowIdGen { row_id_index: 16 }
                            └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden), s_nationkey(hidden), s_suppkey(hidden)], stream_key: [_row_id, _row_id#1, s_nationkey, s_suppkey], pk_columns: [s_name, _row_id, _row_id#1, s_nationkey, s_suppkey], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamHashJoin { type: LeftSemi, predicate: s_suppkey = ps_suppkey, output: [s_name, s_address, _row_id, _row_id, s_nationkey, s_suppkey] } { left table: 0, right table: 2, left degree table: 1, right degree table: 3 }
        ├── StreamExchange Hash([0]) from 1
        └── StreamExchange Hash([0]) from 4

    Fragment 1
    StreamHashJoin [append_only] { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id] } { left table: 4, right table: 6, left degree table: 5, right degree table: 7 }
    ├── StreamExchange Hash([3]) from 2
    └── StreamExchange Hash([0]) from 3

    Fragment 2
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 8 }

    Fragment 3
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 9 }

    Fragment 4
    StreamProject { exprs: [ps_suppkey, _row_id, ps_partkey, ps_partkey, ps_suppkey] }
    └── StreamFilter { predicate: ($expr1 > $expr2) }
        └── StreamHashJoin { type: Inner, predicate: ps_partkey IS NOT DISTINCT FROM ps_partkey AND ps_suppkey IS NOT DISTINCT FROM ps_suppkey, output: all } { left table: 10, right table: 12, left degree table: 11, right degree table: 13 }
            ├── StreamExchange Hash([0, 1]) from 5
            └── StreamProject { exprs: [ps_partkey, ps_suppkey, (0.5:Decimal * sum(l_quantity)) as $expr2] }
                └── StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [sum(l_quantity), count] } { result table: 20, state tables: [], distinct tables: [] }
                    └── StreamHashJoin { type: LeftOuter, predicate: ps_partkey IS NOT DISTINCT FROM l_partkey AND ps_suppkey IS NOT DISTINCT FROM l_suppkey, output: [ps_partkey, ps_suppkey, l_quantity, _row_id] }
                        ├── left table: 21
                        ├── right table: 23
                        ├── left degree table: 22
                        ├── right degree table: 24
                        ├── StreamExchange Hash([0, 1]) from 9
                        └── StreamExchange Hash([0, 1]) from 10

    Fragment 5
    StreamProject { exprs: [ps_partkey, ps_suppkey, ps_availqty::Decimal as $expr1, _row_id] }
    └── StreamExchange NoShuffle from 6

    Fragment 6
    StreamHashJoin { type: LeftSemi, predicate: ps_partkey = p_partkey, output: [ps_partkey, ps_suppkey, ps_availqty, _row_id] } { left table: 14, right table: 16, left degree table: 15, right degree table: 17 }
    ├── StreamExchange Hash([0]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 5 }
    └── StreamSource { source: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id] } { source state table: 18 }

    Fragment 8
    StreamProject { exprs: [p_partkey, _row_id] }
    └── StreamRowIdGen { row_id_index: 9 }
        └── StreamSource { source: part, columns: [p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id] } { source state table: 19 }

    Fragment 9
    StreamProject { exprs: [ps_partkey, ps_suppkey] }
    └── StreamHashAgg { group_key: [ps_partkey, ps_suppkey], aggs: [count] } { result table: 25, state tables: [], distinct tables: [] }
        └── StreamExchange NoShuffle from 6

    Fragment 10
    StreamProject { exprs: [l_partkey, l_suppkey, l_quantity, _row_id] }
    └── StreamFilter { predicate: IsNotNull(l_partkey) AND IsNotNull(l_suppkey) }
        └── StreamRowIdGen { row_id_index: 16 }
            └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
                └── source state table: 26

    Table 0 { columns: [ s_suppkey, s_name, s_address, _row_id, s_nationkey, _row_id_0 ], primary key: [ $0 ASC, $3 ASC, $5 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1 { columns: [ s_suppkey, _row_id, _row_id_0, s_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 2 { columns: [ ps_suppkey, _row_id, ps_partkey, ps_partkey_0, ps_suppkey_0 ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 3 { columns: [ ps_suppkey, _row_id, ps_partkey, ps_partkey_0, ps_suppkey_0, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC ], value indices: [ 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 5 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 6 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 7 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 9 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 10 { columns: [ ps_partkey, ps_suppkey, $expr1, _row_id ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 11 { columns: [ ps_partkey, ps_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 12 { columns: [ ps_partkey, ps_suppkey, $expr2 ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 13 { columns: [ ps_partkey, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 14 { columns: [ ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id ], primary key: [ $0 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ ps_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ p_partkey, _row_id ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ p_partkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 20 { columns: [ ps_partkey, ps_suppkey, sum(l_quantity), count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 21 { columns: [ ps_partkey, ps_suppkey ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 0, 1 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 22 { columns: [ ps_partkey, ps_suppkey, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 23 { columns: [ l_partkey, l_suppkey, l_quantity, _row_id ], primary key: [ $0 ASC, $1 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 24 { columns: [ l_partkey, l_suppkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC ], value indices: [ 3 ], distribution key: [ 0, 1 ], read pk prefix len hint: 2 }

    Table 25 { columns: [ ps_partkey, ps_suppkey, count ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 2 }

    Table 26 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, s_address, _row_id, _row_id#1, s_nationkey, s_suppkey ], primary key: [ $0 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC ], value indices: [ 0, 1, 2, 3, 4, 5 ], distribution key: [ 5 ], read pk prefix len hint: 4 }

- id: tpch_q21
  before:
  - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
    group by
      s_name
    order by
      numwait desc,
      s_name;
  logical_plan: |-
    LogicalProject { exprs: [s_name, count] }
    └─LogicalAgg { group_key: [s_name], aggs: [count] }
      └─LogicalProject { exprs: [s_name] }
        └─LogicalFilter { predicate: (s_suppkey = l_suppkey) AND (o_orderkey = l_orderkey) AND (l_receiptdate > l_commitdate) AND (s_nationkey = n_nationkey) }
          └─LogicalApply { type: LeftAnti, on: true, correlated_id: 2 }
            ├─LogicalApply { type: LeftSemi, on: true, correlated_id: 1 }
            │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ ├─LogicalJoin { type: Inner, on: true, output: all }
            │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ │ └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
            │ └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
            │   └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 1 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 1 }) }
            │     └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
            └─LogicalProject { exprs: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
              └─LogicalFilter { predicate: (l_orderkey = CorrelatedInputRef { index: 8, correlated_id: 2 }) AND (l_suppkey <> CorrelatedInputRef { index: 10, correlated_id: 2 }) AND (l_receiptdate > l_commitdate) }
                └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  optimized_logical_plan_for_batch: |-
    LogicalAgg { group_key: [s_name], aggs: [count] }
    └─LogicalJoin { type: LeftAnti, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: [s_name] }
      ├─LogicalJoin { type: LeftSemi, on: (l_orderkey = l_orderkey) AND (l_suppkey <> l_suppkey), output: all }
      │ ├─LogicalJoin { type: Inner, on: (o_orderkey = l_orderkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ ├─LogicalJoin { type: Inner, on: (s_nationkey = n_nationkey), output: [s_name, l_orderkey, l_suppkey] }
      │ │ │ ├─LogicalJoin { type: Inner, on: (s_suppkey = l_suppkey), output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
      │ │ │ │ ├─LogicalSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], time_range: (Unbounded, Unbounded) }
      │ │ │ │ └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
      │ │ │ │   └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
      │ │ │ └─LogicalSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], time_range: (Unbounded, Unbounded) }
      │ │ └─LogicalSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], time_range: (Unbounded, Unbounded) }
      │ └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
      │   └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
      └─LogicalProject { exprs: [l_orderkey, l_suppkey] }
        └─LogicalFilter { predicate: (l_receiptdate > l_commitdate) }
          └─LogicalSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], time_range: (Unbounded, Unbounded) }
  batch_plan: |-
    BatchExchange { order: [count DESC, s_name ASC], dist: Single }
    └─BatchSort { order: [count DESC, s_name ASC] }
      └─BatchHashAgg { group_key: [s_name], aggs: [count] }
        └─BatchExchange { order: [], dist: HashShard(s_name) }
          └─BatchHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name] }
            ├─BatchHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: all }
            │ ├─BatchHashJoin { type: Inner, predicate: l_orderkey = o_orderkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ ├─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │ │ │ └─BatchHashJoin { type: Inner, predicate: s_nationkey = n_nationkey, output: [s_name, l_orderkey, l_suppkey] }
            │ │ │   ├─BatchExchange { order: [], dist: HashShard(s_nationkey) }
            │ │ │   │ └─BatchHashJoin { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, s_nationkey, l_orderkey, l_suppkey] }
            │ │ │   │   ├─BatchExchange { order: [], dist: HashShard(s_suppkey) }
            │ │ │   │   │ └─BatchSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id], filter: (None, None) }
            │ │ │   │   └─BatchExchange { order: [], dist: HashShard(l_suppkey) }
            │ │ │   │     └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
            │ │ │   │       └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
            │ │ │   └─BatchExchange { order: [], dist: HashShard(n_nationkey) }
            │ │ │     └─BatchSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id], filter: (None, None) }
            │ │ └─BatchExchange { order: [], dist: HashShard(o_orderkey) }
            │ │   └─BatchSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id], filter: (None, None) }
            │ └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
            │   └─BatchProject { exprs: [l_orderkey, l_suppkey] }
            │     └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
            └─BatchExchange { order: [], dist: HashShard(l_orderkey) }
              └─BatchProject { exprs: [l_orderkey, l_suppkey] }
                └─BatchFilter { predicate: (l_receiptdate > l_commitdate) }
                  └─BatchSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id], filter: (None, None) }
  stream_plan: |-
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    └─StreamHashAgg { group_key: [s_name], aggs: [count] }
      └─StreamExchange { dist: HashShard(s_name) }
        └─StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
          ├─StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
          │ ├─StreamExchange { dist: HashShard(l_orderkey) }
          │ │ └─StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
          │ │   ├─StreamExchange { dist: HashShard(s_suppkey) }
          │ │   │ └─StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
          │ │   │   ├─StreamExchange { dist: HashShard(n_nationkey) }
          │ │   │   │ └─StreamRowIdGen { row_id_index: 4 }
          │ │   │   │   └─StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] }
          │ │   │   └─StreamExchange { dist: HashShard(s_nationkey) }
          │ │   │     └─StreamRowIdGen { row_id_index: 7 }
          │ │   │       └─StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] }
          │ │   └─StreamExchange { dist: HashShard(l_suppkey) }
          │ │     └─StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
          │ │       ├─StreamExchange { dist: HashShard(o_orderkey) }
          │ │       │ └─StreamRowIdGen { row_id_index: 9 }
          │ │       │   └─StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] }
          │ │       └─StreamExchange { dist: HashShard(l_orderkey) }
          │ │         └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
          │ │           └─StreamShare { id: 11 }
          │ │             └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
          │ │               └─StreamRowIdGen { row_id_index: 16 }
          │ │                 └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          │ └─StreamExchange { dist: HashShard(l_orderkey) }
          │   └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
          │     └─StreamShare { id: 11 }
          │       └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
          │         └─StreamRowIdGen { row_id_index: 16 }
          │           └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
          └─StreamExchange { dist: HashShard(l_orderkey) }
            └─StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
              └─StreamFilter { predicate: (l_receiptdate > l_commitdate) }
                └─StreamShare { id: 11 }
                  └─StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
                    └─StreamRowIdGen { row_id_index: 16 }
                      └─StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
  stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [s_name, numwait], stream_key: [s_name], pk_columns: [numwait, s_name], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamHashAgg { group_key: [s_name], aggs: [count] } { result table: 0, state tables: [], distinct tables: [] }
        └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamHashJoin { type: LeftAnti, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey, l_orderkey] }
    ├── left table: 1
    ├── right table: 3
    ├── left degree table: 2
    ├── right degree table: 4
    ├── StreamHashJoin { type: LeftSemi, predicate: l_orderkey = l_orderkey AND (l_suppkey <> l_suppkey), output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, _row_id, _row_id, o_orderkey, s_suppkey] }
    │   ├── left table: 5
    │   ├── right table: 7
    │   ├── left degree table: 6
    │   ├── right degree table: 8
    │   ├── StreamExchange Hash([1]) from 2
    │   └── StreamExchange Hash([0]) from 10
    └── StreamExchange Hash([0]) from 11

    Fragment 2
    StreamHashJoin [append_only] { type: Inner, predicate: s_suppkey = l_suppkey, output: [s_name, l_orderkey, l_suppkey, _row_id, _row_id, n_nationkey, s_suppkey, _row_id, _row_id, o_orderkey] }
    ├── left table: 9
    ├── right table: 11
    ├── left degree table: 10
    ├── right degree table: 12
    ├── StreamExchange Hash([0]) from 3
    └── StreamExchange Hash([1]) from 6

    Fragment 3
    StreamHashJoin [append_only] { type: Inner, predicate: n_nationkey = s_nationkey, output: [s_suppkey, s_name, _row_id, n_nationkey, _row_id] }
    ├── left table: 13
    ├── right table: 15
    ├── left degree table: 14
    ├── right degree table: 16
    ├── StreamExchange Hash([0]) from 4
    └── StreamExchange Hash([3]) from 5

    Fragment 4
    StreamRowIdGen { row_id_index: 4 }
    └── StreamSource { source: nation, columns: [n_nationkey, n_name, n_regionkey, n_comment, _row_id] } { source state table: 17 }

    Fragment 5
    StreamRowIdGen { row_id_index: 7 }
    └── StreamSource { source: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id] } { source state table: 18 }

    Fragment 6
    StreamHashJoin [append_only] { type: Inner, predicate: o_orderkey = l_orderkey, output: [l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id] }
    ├── left table: 19
    ├── right table: 21
    ├── left degree table: 20
    ├── right degree table: 22
    ├── StreamExchange Hash([0]) from 7
    └── StreamExchange Hash([0]) from 8

    Fragment 7
    StreamRowIdGen { row_id_index: 9 }
    └── StreamSource { source: orders, columns: [o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id] } { source state table: 23 }

    Fragment 8
    StreamFilter { predicate: (l_receiptdate > l_commitdate) }
    └── StreamExchange NoShuffle from 9

    Fragment 9
    StreamProject { exprs: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id] }
    └── StreamRowIdGen { row_id_index: 16 }
        └── StreamSource { source: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment, _row_id] }
            └── source state table: 24

    Fragment 10
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamExchange NoShuffle from 9

    Fragment 11
    StreamProject { exprs: [l_orderkey, l_suppkey, _row_id] }
    └── StreamFilter { predicate: (l_receiptdate > l_commitdate) }
        └── StreamExchange NoShuffle from 9

    Table 0 { columns: [ s_name, count ], primary key: [ $0 ASC ], value indices: [ 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC, $8 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 2
    ├── columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 3 { columns: [ l_orderkey, l_suppkey, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 4 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 5
    ├── columns: [ s_name, l_orderkey, l_suppkey, _row_id, _row_id_0, n_nationkey, s_suppkey, _row_id_1, _row_id_2, o_orderkey ]
    ├── primary key: [ $1 ASC, $3 ASC, $4 ASC, $5 ASC, $7 ASC, $8 ASC, $9 ASC, $6 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 6
    ├── columns: [ l_orderkey, _row_id, _row_id_0, n_nationkey, _row_id_1, _row_id_2, o_orderkey, s_suppkey, _degree ]
    ├── primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC, $4 ASC, $5 ASC, $6 ASC, $7 ASC ]
    ├── value indices: [ 8 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 7 { columns: [ l_orderkey, l_suppkey, _row_id ], primary key: [ $0 ASC, $2 ASC ], value indices: [ 0, 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 8 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 9 { columns: [ s_suppkey, s_name, _row_id, n_nationkey, _row_id_0 ], primary key: [ $0 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 10 { columns: [ s_suppkey, _row_id, _row_id_0, n_nationkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 11 { columns: [ l_orderkey, l_suppkey, _row_id, o_orderkey, _row_id_0 ], primary key: [ $1 ASC, $2 ASC, $4 ASC, $3 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 1 ], read pk prefix len hint: 1 }

    Table 12 { columns: [ l_suppkey, _row_id, _row_id_0, o_orderkey, _degree ], primary key: [ $0 ASC, $1 ASC, $2 ASC, $3 ASC ], value indices: [ 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 13 { columns: [ n_nationkey, n_name, n_regionkey, n_comment, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 14 { columns: [ n_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 15 { columns: [ s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id ], primary key: [ $3 ASC, $7 ASC ], value indices: [ 0, 1, 2, 3, 4, 5, 6, 7 ], distribution key: [ 3 ], read pk prefix len hint: 1 }

    Table 16 { columns: [ s_nationkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 17 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 18 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 19
    ├── columns: [ o_orderkey, o_custkey, o_orderstatus, o_totalprice, o_orderdate, o_orderpriority, o_clerk, o_shippriority, o_comment, _row_id ]
    ├── primary key: [ $0 ASC, $9 ASC ]
    ├── value indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 20 { columns: [ o_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 21 { columns: [ l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id ], primary key: [ $0 ASC, $4 ASC ], value indices: [ 0, 1, 2, 3, 4 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 22 { columns: [ l_orderkey, _row_id, _degree ], primary key: [ $0 ASC, $1 ASC ], value indices: [ 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 23 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 24 { columns: [ partition_id, offset_info ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 1 }

    Table 4294967294 { columns: [ s_name, numwait ], primary key: [ $1 DESC, $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

